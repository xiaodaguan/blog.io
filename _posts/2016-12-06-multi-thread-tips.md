---
layout: post
title: 多线程笔记
date: 2016-12-06
categories: blog
tags: [多线程]
description: 
---

## 多线程笔记﻿

- 竞态条件，临界区
多个线程竞争统一资源，如果对资源的访问顺序敏感，则称存在竞态条件
导致竞态条件的代码区称为临界区
- 线程安全
线程安全的代码不应该包含竞态条件
- 不可变对象
不可变对象是线程安全的，例如：类的成员变量由构造函数赋值且没有set方法
注意：”只读"不一定等同于”不变”，例如：一个人的出生年月日是”不变”属性，但年龄是”只读”属性，随着时间的变化，人的生日不变，年龄会改变
不可变对象是线程安全的，但使用不可变对象的类不一定是线程安全的
- 同步块
同步块可以保证同一时刻仅有一个线程可以进入临界区
- volatile
一个变量声明为volatile，意味着这个变量是随时会被其他线程修改的
volatile 修饰后的变量，任何线程修改了改的值，其他所有线程自动获得相同的值
volatile 用于声明简单类型变量，如果这些变量被声明为volatile，对它们的操作就会变成原子级
但如果对volatile变量的操作当前值与该变量以前的值相关，那么该操作就不是原子操作，例如：
对于volatile int n=0;
n++, n+=1都不是原子操作, n=m+1则是原子操作
- synchronized
  + 实例方法同步
  + 静态方法同步
  + 实例方法中的同步块
  + 静态方法中的同步块 
synchronized锁住的是什么很关键，要注意
例如：synchronized(this)只能锁住一个对象，如果是多个线程同时进入不同的对象中的这一段代码，是可以进入的
如果想彻底的锁住一个代码段，可以用synchronized(SomeClass.class)
静态方法同步同样道理，也相当于全局锁住代码块
- 线程通信
  + 共享对象
  + 忙等
  + wait(), notify()
- 线程封闭的3种方法
  - ad-hoc，完全靠实现者，非常脆弱，不推荐
  - 栈封闭，局部变量
  - threadlocal，map<线程名，封闭对象> 实现